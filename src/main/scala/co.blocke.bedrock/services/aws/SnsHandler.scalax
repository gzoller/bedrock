import zio._
import zio.http._
import zio.json._

import java.net.URI
import zio.http.model.Method

object SnsHandler extends ZIOAppDefault {

  // Define a case class for SNS messages
  case class SnsMessage(Type: String, SubscribeURL: Option[String], Message: Option[String])

  // Define JSON decoders for SNS messages
  implicit val snsMessageDecoder: JsonDecoder[SnsMessage] = DeriveJsonDecoder.gen[SnsMessage]

  // Confirm the subscription by sending a GET request to the SubscribeURL
  def confirmSubscription(subscribeUrl: String): ZIO[Any, Throwable, Unit] =
    Client
      .request(Request.get(URI.create(subscribeUrl)))
      .flatMap { response =>
        if (response.status.isSuccess) ZIO.logInfo("Subscription confirmed!")
        else ZIO.fail(new RuntimeException(s"Failed to confirm subscription: ${response.status}"))
      }

  // ZIO HTTP App to handle SNS messages
  val snsHandler: App[Any] = Http.collectZIO[Request] {
    case req @ Method.POST -> !! / "sns-handler" =>
      for {
        body       <- req.body.asString
        snsMessage <- ZIO.fromEither(body.fromJson[SnsMessage]).orElseFail(new RuntimeException("Invalid JSON"))
        _ <- snsMessage.Type match {
          case "SubscriptionConfirmation" =>
            snsMessage.SubscribeURL match {
              case Some(subscribeUrl) => confirmSubscription(subscribeUrl)
              case None               => ZIO.fail(new RuntimeException("Missing SubscribeURL in SubscriptionConfirmation"))
            }

          case "Notification" =>
            snsMessage.Message match {
              case Some(message) => ZIO.logInfo(s"Received SNS notification: $message")
              case None          => ZIO.fail(new RuntimeException("Missing Message in Notification"))
            }

          case _ =>
            ZIO.fail(new RuntimeException(s"Unknown SNS message type: ${snsMessage.Type}"))
        }
      } yield Response.status(Status.Ok)
  }

  // Start the ZIO HTTP server
  override def run: ZIO[Any with ZIOAppArgs with Scope, Throwable, Unit] =
    Server
      .serve(snsHandler)
      .provide(Server.default, Client.default)
}




val unsubscribeOnShutdown: ZIO[Any, Throwable, Unit] = {
  val subscriptionArn = "arn:aws:sns:us-east-1:123456789012:example-topic:subscription-id"
  val snsClient = SnsClient.create()

  ZIO.attempt {
    snsClient.unsubscribe(UnsubscribeRequest.builder()
      .subscriptionArn(subscriptionArn)
      .build())
  }.tapError(err => ZIO.logError(s"Failed to unsubscribe: ${err.getMessage}"))
}


// NOTE: SNS doesn't clean up dead subscribers!!!  You need to shut down gracefully.
// If servers hard-crash then they will start spewing errors so something (or someone)
// must monitor that and manually clean up dead SNS subscribers.


/* ----------- new


// Mix with signing
def verifySnsRequest(req: Request): Task[Boolean] = for {
  (ipv4Ranges, ipv6Ranges) <- fetchAwsIpRanges
  ipVerified <- verifyIp(req, ipv4Ranges, ipv6Ranges)
  signatureVerified <- if (ipVerified) {
    // Perform signature verification
    for {
      certUrl <- ZIO.fromOption(req.headers.header("x-amz-sns-signing-cert-url")).map(_.value).orElseFail(new Exception("Missing cert URL"))
      signature <- ZIO.fromOption(req.headers.header("x-amz-sns-signature")).map(_.value).orElseFail(new Exception("Missing signature"))
      publicKey <- SnsCertificateCache.getSigningPublicKey(certUrl)
      body <- req.body.asString
      isValid <- validateSignature(publicKey, body, signature)
    } yield isValid
  } else ZIO.succeed(false)
} yield signatureVerified


import zio._
import zio.http._
import java.net.URL
import java.security.cert.CertificateFactory
import java.security.{PublicKey, Signature}
import java.util.Base64

  def verifySnsRequest(req: Request): Task[Boolean] = {
    for {
      snsType <- ZIO.fromOption(req.headers.header("x-amz-sns-message-type")).map(_.value).orElseFail(new Exception("Missing x-amz-sns-message-type header"))
      certUrl <- ZIO.fromOption(req.headers.header("x-amz-sns-signing-cert-url")).map(_.value).orElseFail(new Exception("Missing x-amz-sns-signing-cert-url header"))
      signature <- ZIO.fromOption(req.headers.header("x-amz-sns-signature")).map(_.value).orElseFail(new Exception("Missing x-amz-sns-signature header"))
      publicKey <- fetchSigningPublicKey(certUrl)
      body <- req.body.asString
      isValid <- validateSignature(publicKey, body, signature)
    } yield isValid
  }

  def fetchSigningPublicKey(certUrl: String): Task[PublicKey] = ZIO.attempt {
    val url = new URL(certUrl)
    val certStream = url.openStream()
    val certificateFactory = CertificateFactory.getInstance("X.509")
    val certificate = certificateFactory.generateCertificate(certStream)
    certStream.close()
    certificate.getPublicKey
  }

  def validateSignature(publicKey: PublicKey, message: String, signature: String): Task[Boolean] = ZIO.attempt {
    val signatureBytes = Base64.getDecoder.decode(signature)
    val sig = Signature.getInstance("SHA1withRSA")
    sig.initVerify(publicKey)
    sig.update(message.getBytes("UTF-8"))
    sig.verify(signatureBytes)
  }
*/